<!DOCTYPE html>
  <head>
    <meta charset="UTF-8">
    <title>Compilador en JavaScript</title>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
  </head>
  <body>
    <h1>Compilador en JavaScript</h1>
    <label for="codigo">Código fuente:</label>
    <br>
    <textarea id="codigo" rows="10" cols="50"></textarea>
    <br>
    <button onclick="compilar()">Compilar</button>
    <h2>Análisis léxico:</h2>
    <pre id="lexico"></pre>
    <h2>Análisis sintáctico:</h2>
    <pre id="sintactico"></pre>
    <h2>Análisis semántico:</h2>
    <pre id="semantico"></pre>
    <h2>Código objeto:</h2>
    <pre id="codigo-objeto"></pre>
  </body>
  <script>
    function compilar() {
      const codigo = document.getElementById('codigo').value;
      const tokens = analizarLexico(codigo);
      const arbolSintaxis = analizarSintaxis(tokens);
      const tablaSimbolos = analizarSemantica(arbolSintaxis);
      const codigoObjeto = generarCodigo(arbolSintaxis, tablaSimbolos);
      mostrarAnalisisLexico(tokens);
      mostrarAnalisisSintactico(arbolSintaxis);
      mostrarAnalisisSemantico(tablaSimbolos);
      mostrarCodigoObjeto(codigoObjeto);
    }

function analizarLexico(codigo) {

  const tokens = [];
  const palabrasReservadas = ['if', 'else', 'while', 'for', 'return', 'int', 'float', 'char', 'bool'];
  const expresionesRegulares = [
    {tipo: 'ENTERO', patron: /^\d+/},
    {tipo: 'DECIMAL', patron: /^\d+\.\d+/},
    {tipo: 'IDENTIFICADOR', patron: /^[a-zA-Z]+[a-zA-Z0-9]*/},
    {tipo: 'ASIGNACION', patron: /^=/},
    {tipo: 'PARENTESIS_IZQUIERDO', patron: /^\(/},
    {tipo: 'PARENTESIS_DERECHO', patron: /^\)/},
    {tipo: 'LLAVE_IZQUIERDA', patron: /^{/},
    {tipo: 'LLAVE_DERECHA', patron: /^}/},
    {tipo: 'CORCHETE_IZQUIERDO', patron: /^\[/},
    {tipo: 'CORCHETE_DERECHO', patron: /^]/},
    {tipo: 'SUMA', patron: /^\+/},
    {tipo: 'RESTA', patron: /^-/},
    {tipo: 'MULTIPLICACION', patron: /^\*/},
    {tipo: 'DIVISION', patron: /^\//},
    {tipo: 'MENOR', patron: /^</},
    {tipo: 'MAYOR', patron: /^>/},
    {tipo: 'MENOR_O_IGUAL', patron: /^<=/},
    {tipo: 'MAYOR_O_IGUAL', patron: /^>=/},
    {tipo: 'IGUALDAD', patron: /^==/},
    {tipo: 'DISTINTO', patron: /^!=/},
    {tipo: 'AND', patron: /^&&/},
    {tipo: 'OR', patron: /^\|\|/},
    {tipo: 'NOT', patron: /^!/},
    {tipo: 'PUNTO_Y_COMA', patron: /^;/},
    {tipo: 'COMA', patron: /^,/},
    {tipo: 'FIN_ARCHIVO', patron: /^$/},
  ];

  let linea = 1;
  let columna = 1;
  while (codigo.length > 0) {
    debugger
    let match = null;
    for (let i = 0; i < expresionesRegulares.length; i++) {
      const expresion = expresionesRegulares[i];
      match = codigo.match(expresion.patron);
      if (match) {
        const valor = match[0];
        codigo = codigo.slice(valor.length);
        columna += valor.length;
        if (expresion.tipo === 'IDENTIFICADOR' && palabrasReservadas.includes(valor)) {
          tokens.push({tipo: valor.toUpperCase(), valor, linea, columna});
        } else {
          tokens.push({tipo: expresion.tipo, valor, linea, columna});
        }
        break;
      }
    }
    if (!match) {
      const caracter = codigo[0];
      codigo = codigo.slice(1);
      columna++;
      if (caracter === '\n') {
        linea++;
        columna = 1;
      }
      tokens.push({tipo: 'DESCONOCIDO', valor: caracter, linea, columna});
    }
  }

  return tokens;
}

function analizarSintaxis(tokens) {
  let indice = 0;

  function consumir(tipo) {


    if (tokens[indice].tipo === tipo) {
      indice++;
    } else {
      throw new Error(`Error de sintaxis en la línea ${tokens[indice].linea}, columna ${tokens[indice].columna}: se esperaba ${tipo}, pero se encontró ${tokens[indice].tipo}`);
    }
  }

  function programa() {

    while (tokens[indice].tipo !== 'FIN_ARCHIVO') {
      declaracion();
    }
  }

  function declaracion() {
    if (tokens[indice].tipo === 'ENTERO' || tokens[indice].tipo === 'DECIMAL' || tokens[indice].tipo === 'CHAR' || tokens[indice].tipo === 'BOOL') {
      debugger
      const tipo = tokens[indice].tipo;
      consumir(tipo);
      const identificador = tokens[indice].valor;
      consumir('IDENTIFICADOR');
      if (tokens[indice].tipo === 'PARENTESIS_IZQUIERDO') {
        consumir('PARENTESIS_IZQUIERDO');
        consumir('PARENTESIS_DERECHO');
        bloque();
      } else {
        if (tokens[indice].tipo === 'ASIGNACION') {
          consumir('ASIGNACION');
          expresion();
        }
        consumir('PUNTO_Y_COMA');
      }
    } else {
      throw new Error(`Error de sintaxis en la línea ${tokens[indice].linea}, columna ${tokens[indice].columna}: se esperaba una declaración de variable, pero se encontró ${tokens[indice].tipo}`);
    }
  }

  function bloque() {
    consumir('LLAVE_IZQUIERDA');
    while (tokens[indice].tipo !== 'LLAVE_DERECHA') {
      declaracion();
    }
    consumir('LLAVE_DERECHA');
  }

  function expresion() {
    termino();
    while (tokens[indice].tipo === 'SUMA' || tokens[indice].tipo === 'RESTA') {
      consumir(tokens[indice].tipo);
      termino();
    }
  }

  function termino() {
    factor();
    while (tokens[indice].tipo === 'MULTIPLICACION' || tokens[indice].tipo === 'DIVISION') {
      consumir(tokens[indice].tipo);
      factor();
    }
  }

  function factor() {
    if (tokens[indice].tipo === 'ENTERO' || tokens[indice].tipo === 'DECIMAL' || tokens[indice].tipo === 'IDENTIFICADOR') {
      consumir(tokens[indice].tipo);
    } else if (tokens[indice].tipo === 'PARENTESIS_IZQUIERDO') {
      consumir('PARENTESIS_IZQUIERDO');
      expresion();
      consumir('PARENTESIS_DERECHO');
    } else {
      throw new Error(`Error de sintaxis en la línea ${tokens[indice].linea}, columna ${tokens[indice].columna}: se esperaba un número, una variable o un paréntesis, pero se encontró ${tokens[indice].tipo}`);
    }
  }

  programa();
}

function analizarSemantica(ast) {
  const variables = {};

  function analizarNodo(nodo) {
    switch (nodo.tipo) {
      case 'PROGRAMA':
        nodo.declaraciones.forEach(analizarNodo);
        break;
      case 'DECLARACION':
        if (nodo.tipoVariable in variables) {
          throw new Error(`Error semántico en la línea ${nodo.linea}, columna ${nodo.columna}: la variable "${nodo.identificador}" ya ha sido declarada`);
        } else {
          variables[nodo.identificador] = nodo.tipoVariable;
        }
        if (nodo.expresion) {
          analizarNodo(nodo.expresion);
        }
        break;
      case 'ASIGNACION':
        if (!(nodo.identificador in variables)) {
          throw new Error(`Error semántico en la línea ${nodo.linea}, columna ${nodo.columna}: la variable "${nodo.identificador}" no ha sido declarada`);
        } else {
          const tipoVariable = variables[nodo.identificador];
          const tipoExpresion = analizarNodo(nodo.expresion);
          if (tipoVariable !== tipoExpresion) {
            throw new Error(`Error semántico en la línea ${nodo.linea}, columna ${nodo.columna}: no se puede asignar una expresión de tipo "${tipoExpresion}" a una variable de tipo "${tipoVariable}"`);
          }
        }
        break;
      case 'ENTERO':
        return 'ENTERO';
      case 'IDENTIFICADOR':
        if (!(nodo.valor in variables)) {
          throw new Error(`Error semántico en la línea ${nodo.linea}, columna ${nodo.columna}: la variable "${nodo.valor}" no ha sido declarada`);
        } else {
          return variables[nodo.valor];
        }
      case 'SUMA':
      case 'RESTA':
      case 'MULTIPLICACION':
      case 'DIVISION':
        const tipoIzquierdo = analizarNodo(nodo.izquierdo);
        const tipoDerecho = analizarNodo(nodo.derecho);
        if (tipoIzquierdo !== 'ENTERO' || tipoDerecho !== 'ENTERO') {
          throw new Error(`Error semántico en la línea ${nodo.linea}, columna ${nodo.columna}: se esperaba una expresión de tipo "ENTERO"`);
        }
        return 'ENTERO';
    }
  }

  analizarNodo(ast);
}

    function generarCodigo(arbolSintaxis, tablaSimbolos) {
      // Implementación de la generación de código objeto
    }

    function mostrarAnalisisLexico(tokens) {
      const resultado = tokens.map(token => `[${token.tipo}: ${token.valor}]`).join('\n');
      document.getElementById('lexico').textContent = resultado;
    }

    function mostrarAnalisisSintactico(arbolSintaxis) {
      const resultado = JSON.stringify(arbolSintaxis, null, 2);
      document.getElementById('sintactico').textContent = resultado;
    }

    function mostrarAnalisisSemantico(tablaSimbolos) {
      const resultado = JSON.stringify(tablaSimbolos, null, 2);
      document.getElementById('semantico').textContent = resultado;
    }

    function mostrarCodigoObjeto(codigoObjeto) {
      document.getElementById('codigo-objeto').textContent = codigoObjeto;
    }
  </script>
</html>